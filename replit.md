# TransQuote - Transportation Quote SaaS

## Overview

TransQuote is a B2B SaaS application for calculating transportation quotes based on route distance, vehicle type, and zone-based pricing rules. The system integrates with OpenRouteService for real-time distance calculation and provides administrators with tools to manage pricing zones, vehicle types, and quote history.

**Core Value Proposition**: Automated quote generation using real-world routing data, eliminating manual distance estimation and pricing calculation errors.

**Tech Stack Summary**:
- Frontend: React + TypeScript with Vite
- Backend: Express + TypeScript
- Database: PostgreSQL via Neon with Drizzle ORM
- Routing API: OpenRouteService
- UI Framework: shadcn/ui with Tailwind CSS

## User Preferences

- Preferred communication style: Simple, everyday language
- Language: Spanish (todo en español)
- Features: Dark/light theme toggle (activated), Dashboard shows 0 values (pre-launch state)
- Architecture: Role-based access control (admin vs customer)

## System Architecture

### Application Structure

**Monorepo Organization**:
- `/client` - React SPA frontend
- `/server` - Express REST API backend  
- `/shared` - Shared TypeScript schemas and types (Drizzle schemas, Zod validators)
- `/migrations` - Database migrations generated by Drizzle Kit

**Rationale**: Sharing type definitions between client and server ensures type safety across the API boundary and reduces duplication. The monorepo structure simplifies development and deployment.

### Frontend Architecture

**Role-Based Access Control (RBAC)**:
- Two user roles: `admin` and `customer`
- Separate routers for each role with protected access
- AdminRouter: Dashboard, Pricing Rules, Vehicle Types
- CustomerRouter: Quote Calculator, History, Contact

**Admin Area** (Protected):
- `/` - Dashboard (0 values - pre-launch)
- `/admin/pricing` - Manage pricing rules
- `/admin/vehicles` - Manage vehicle types

**Customer Area** (Protected):
- `/` - Quote calculator
- `/history` - Quote history
- `/contact` - Contact information

**React SPA with Client-Side Routing**:
- Uses Wouter for lightweight routing
- Context-based state management (AuthContext, ThemeContext)
- React Query (TanStack Query) for server state management
- Form handling via React Hook Form with Zod validation
- ProtectedRoute component enforces role-based access

**Component Philosophy**:
- shadcn/ui components provide accessible, customizable primitives
- Business components built on top of UI primitives
- Design system inspired by Linear and [REDACTED-STRIPE] (clean, data-focused)
- Custom theming via CSS variables for light/dark mode support

**Key Design Decisions**:
- **Role-based routing**: AdminRouter and CustomerRouter are completely separate, preventing customer access to admin areas
- **ProtectedRoute component**: Validates user role before rendering content
- **No global state library**: React Query handles server state, Context API handles auth/theme/role
- **Composition over configuration**: Components are copied into codebase (shadcn pattern)
- **Type-safe API calls**: Shared schemas ensure frontend and backend agree on data structures

### Backend Architecture

**Express REST API**:
- TypeScript for type safety
- Session-based authentication with mock admin user (Carlos Admin)
- RESTful endpoints for CRUD operations on pricing rules, vehicle types, and quotes
- Role information stored in session (not yet persisted, currently mock)

**Service Layer**:
- `openrouteservice.ts` - External API integration for geocoding and routing
- `storage.ts` - Data access abstraction (in-memory mock with plans for database implementation)

**Key Design Decisions**:
- **Service abstraction**: `IStorage` interface allows swapping between in-memory and database implementations
- **Memoization potential**: Distance calculations can be cached since routes rarely change
- **Error handling**: API errors are caught and returned with appropriate HTTP status codes

### Database Design

**Schema (Drizzle ORM)**:

**Users Table** (Future):
- Authentication and authorization
- `role` field for admin/customer distinction

**Pricing Rules Table**:
- Zone-based pricing configuration
- Fields: zone number, country, distance range (min/max km), base price, price per km, toll surcharge, minimum price
- Supports multiple countries (España, Portugal, Francia)
- `isActive` flag for soft deletion

**Vehicle Types Table**:
- Vehicle configurations with capacity information
- `priceMultiplier` adjusts base pricing per vehicle
- Current types: Moto (1.0x), Furgoneta (1.0x), Furgón (1.0x), Carrozado (1.0x)

**Quotes Table**:
- Historical quote storage
- Fields: origin/destination addresses, coordinates, distance, duration, pricing breakdown, selected zone/vehicle, final price
- Status tracking (pending, accepted, rejected)
- User association for history viewing

**Design Rationale**:
- Pricing rules are configurable rather than hardcoded
- Storing full quote details enables auditing and analytics
- Soft deletion via `isActive` preserves historical data

### Authentication Strategy

**Current Implementation**: Mock authentication
- Default user: Carlos Admin (admin role)
- Authentication system ready for Replit Auth integration
- Role-based route access enforced client-side

**Planned Implementation**: Replit Auth + Database session store
- OAuth-based authentication
- Session management via `express-session` with PostgreSQL session store (`connect-pg-simple`)
- Role-based access: regular users can create quotes, admins can modify pricing rules and vehicle types

**Rationale**: OAuth simplifies user management (no password storage) and Replit Auth integrates seamlessly with the Replit deployment environment.

### Quote Calculation Logic

**Multi-Step Process**:

1. **Geocoding**: Convert origin/destination addresses to coordinates via OpenRouteService
2. **Route Calculation**: Get actual driving distance and duration
3. **Zone Selection**: Match distance + destination country to pricing rule
4. **Price Calculation**:
   - Base price from zone
   - Distance cost = distance × price per km
   - Toll surcharge = (base + distance cost) × toll percentage
   - Vehicle adjustment = total × vehicle multiplier
   - Apply minimum price threshold

**Design Rationale**:
- Using actual routing API eliminates "as the crow flies" distance errors
- Zone-based pricing supports different rates for local vs. international transport
- Vehicle multiplier keeps base pricing simple while accommodating different vehicle sizes

### API Integration

**OpenRouteService**:
- Geocoding API: Address → coordinates + country detection
- Directions API: Route calculation with distance/duration
- API key stored in ORS_API_KEY environment variable

**Error Handling**:
- Invalid addresses return user-friendly error messages
- API rate limits are handled gracefully (though not currently implemented)
- Failed geocoding suggests address corrections

**Future Consideration**: Caching geocoding results and route distances for frequently requested routes could reduce API costs.

## External Dependencies

### Core Infrastructure

**Database**: 
- PostgreSQL (via Neon serverless)
- Drizzle ORM for type-safe queries
- Database URL configured via `DATABASE_URL` environment variable

**Session Store**: 
- `connect-pg-simple` stores Express sessions in PostgreSQL
- Enables horizontal scaling without sticky sessions

### Third-Party APIs

**OpenRouteService**:
- Purpose: Geocoding and route calculation
- API key: `ORS_API_KEY` environment variable
- Base URL: `https://api.openrouteservice.org`
- Endpoints used:
  - `/geocode/search` - Address to coordinates
  - `/v2/directions/driving-car` - Route with distance/duration

### UI & Styling

**shadcn/ui**:
- Radix UI primitives for accessibility
- Tailwind CSS for styling
- Component library copied into project for full control

**Fonts**:
- Inter (via Google Fonts) for UI text
- JetBrains Mono for numerical data and code
- Loaded via CDN in `index.html`

**Theme System**:
- Light/dark mode toggle via ThemeContext
- localStorage persistence of theme preference
- System preference detection as fallback
- CSS variables for semantic colors

### Development Tools

**Vite**:
- Development server with HMR
- Build tool for production bundle
- Replit-specific plugins for debugging and deployment

**ESBuild**:
- Server-side bundling for production
- Selective bundling of dependencies to reduce cold start times

**TypeScript**:
- Strict mode enabled
- Shared types between client/server via path aliases

### Authentication (Planned)

**Replit Auth**:
- OAuth provider integration
- No additional API keys required when deployed on Replit
- Falls back to mock auth in development

### Package Management

**Key Dependencies**:
- `@tanstack/react-query` - Server state management
- `react-hook-form` + `zod` - Type-safe form validation
- `drizzle-orm` + `drizzle-zod` - Database ORM with Zod integration
- `wouter` - Lightweight routing
- `express-session` - Session management

**Build Tools**:
- `tsx` - TypeScript execution for development
- `esbuild` - Production server bundling
- `drizzle-kit` - Database migration tool

## Recent Changes (v2.0 - Role-Based Architecture)

### 2025-11-30 Architecture Restructure

**Added**:
- ProtectedRoute component for role-based access control
- ContactPage for customers to reach admin
- Role-based routing (AdminRouter, CustomerRouter)
- Support for role distinction in AuthContext

**Modified**:
- AuthContext: Now manages `role` field (admin/customer) instead of `isAdmin` boolean
- App.tsx: Completely restructured with separate routers per role
- AppSidebar: Now displays different menu items based on user role
- QuotePage: Fixed dark mode styling for vehicle selector dropdown
- DashboardPage: All metrics set to 0 (pre-launch state)
- ThemeToggle: Working light/dark mode toggle

**Rationale for RBAC**:
- Customers cannot access dashboard or admin functions
- Admin cannot accidentally access customer areas
- Separates concerns at routing level (complete isolation)
- Easier to enforce permissions and prevent security issues
- Clear separation of business logic between two distinct user types
