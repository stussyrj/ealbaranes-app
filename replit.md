# TransQuote - Transportation Quote SaaS

## Overview

TransQuote is a B2B SaaS application for calculating transportation quotes based on route distance, vehicle type, and zone-based pricing rules. The system integrates with OpenRouteService for real-time distance calculation and provides administrators with tools to manage pricing zones, vehicle types, and quote history.

**Core Value Proposition**: Automated quote generation using real-world routing data, eliminating manual distance estimation and pricing calculation errors.

**Tech Stack Summary**:
- Frontend: React + TypeScript with Vite
- Backend: Express + TypeScript
- Database: PostgreSQL via Neon with Drizzle ORM
- Routing API: OpenRouteService
- UI Framework: shadcn/ui with Tailwind CSS

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Application Structure

**Monorepo Organization**:
- `/client` - React SPA frontend
- `/server` - Express REST API backend  
- `/shared` - Shared TypeScript schemas and types (Drizzle schemas, Zod validators)
- `/migrations` - Database migrations generated by Drizzle Kit

**Rationale**: Sharing type definitions between client and server ensures type safety across the API boundary and reduces duplication. The monorepo structure simplifies development and deployment.

### Frontend Architecture

**React SPA with Client-Side Routing**:
- Uses Wouter for lightweight routing
- Context-based state management (AuthContext, ThemeContext)
- React Query (TanStack Query) for server state management
- Form handling via React Hook Form with Zod validation

**Component Philosophy**:
- shadcn/ui components provide accessible, customizable primitives
- Business components built on top of UI primitives
- Design system inspired by Linear and [REDACTED-STRIPE] (clean, data-focused)
- Custom theming via CSS variables for light/dark mode support

**Key Design Decisions**:
- **No global state library**: React Query handles server state, Context API handles auth/theme (sufficient for this app's complexity)
- **Composition over configuration**: Components are copied into codebase (shadcn pattern) rather than imported from npm, enabling full customization
- **Type-safe API calls**: Shared schemas ensure frontend and backend agree on data structures

### Backend Architecture

**Express REST API**:
- TypeScript for type safety
- Session-based authentication (planned - currently mock OAuth)
- RESTful endpoints for CRUD operations on pricing rules, vehicle types, and quotes

**Service Layer**:
- `openrouteservice.ts` - External API integration for geocoding and routing
- `storage.ts` - Data access abstraction (in-memory mock with plans for database implementation)

**Key Design Decisions**:
- **Service abstraction**: `IStorage` interface allows swapping between in-memory and database implementations without changing route handlers
- **Memoization potential**: Distance calculations can be cached since routes rarely change
- **Error handling**: API errors are caught and returned with appropriate HTTP status codes

### Database Design

**Schema (Drizzle ORM)**:

**Users Table**:
- Authentication and authorization
- `isAdmin` flag for role-based access control

**Pricing Rules Table**:
- Zone-based pricing configuration
- Fields: zone number, country, distance range (min/max km), base price, price per km, toll surcharge, minimum price
- Supports multiple countries (España, Portugal, Francia)
- `isActive` flag for soft deletion

**Vehicle Types Table**:
- Vehicle configurations with capacity information
- `priceMultiplier` adjusts base pricing per vehicle
- Examples: Van (1.0x), Trailer (1.85x)

**Quotes Table**:
- Historical quote storage
- Fields: origin/destination addresses, coordinates, distance, duration, pricing breakdown, selected zone/vehicle, final price
- Status tracking (pending, accepted, rejected)
- User association for history viewing

**Design Rationale**:
- Pricing rules are configurable rather than hardcoded, allowing non-technical users to adjust pricing
- Storing full quote details (including coordinates and breakdowns) enables auditing and analytics
- Soft deletion via `isActive` preserves historical data

### Authentication Strategy

**Current Implementation**: Mock OAuth (development placeholder)

**Planned Implementation**: Replit Auth
- OAuth-based authentication
- Session management via `express-session` with PostgreSQL session store (`connect-pg-simple`)
- Role-based access: regular users can create quotes, admins can modify pricing rules and vehicle types

**Rationale**: OAuth simplifies user management (no password storage) and Replit Auth integrates seamlessly with the Replit deployment environment.

### Quote Calculation Logic

**Multi-Step Process**:

1. **Geocoding**: Convert origin/destination addresses to coordinates via OpenRouteService
2. **Route Calculation**: Get actual driving distance and duration
3. **Zone Selection**: Match distance + destination country to pricing rule
4. **Price Calculation**:
   - Base price from zone
   - Distance cost = distance × price per km
   - Toll surcharge = (base + distance cost) × toll percentage
   - Vehicle adjustment = total × vehicle multiplier
   - Apply minimum price threshold

**Design Rationale**:
- Using actual routing API eliminates "as the crow flies" distance errors
- Zone-based pricing supports different rates for local vs. international transport
- Vehicle multiplier keeps base pricing simple while accommodating different vehicle sizes

### API Integration

**OpenRouteService**:
- Geocoding API: Address → coordinates + country detection
- Directions API: Route calculation with distance/duration
- API key stored in environment variables

**Error Handling**:
- Invalid addresses return user-friendly error messages
- API rate limits are handled gracefully (though not currently implemented)
- Failed geocoding suggests address corrections

**Future Consideration**: Caching geocoding results and route distances for frequently requested routes could reduce API costs.

## External Dependencies

### Core Infrastructure

**Database**: 
- PostgreSQL (via Neon serverless)
- Drizzle ORM for type-safe queries
- Database URL configured via `DATABASE_URL` environment variable

**Session Store**: 
- `connect-pg-simple` stores Express sessions in PostgreSQL
- Enables horizontal scaling without sticky sessions

### Third-Party APIs

**OpenRouteService**:
- Purpose: Geocoding and route calculation
- API key: `ORS_API_KEY` environment variable
- Base URL: `https://api.openrouteservice.org`
- Endpoints used:
  - `/geocode/search` - Address to coordinates
  - `/v2/directions/driving-car` - Route with distance/duration

### UI & Styling

**shadcn/ui**:
- Radix UI primitives for accessibility
- Tailwind CSS for styling
- Component library copied into project for full control

**Fonts**:
- Inter (via Google Fonts) for UI text
- JetBrains Mono for numerical data and code
- Loaded via CDN in `index.html`

### Development Tools

**Vite**:
- Development server with HMR
- Build tool for production bundle
- Replit-specific plugins for debugging and deployment

**ESBuild**:
- Server-side bundling for production
- Selective bundling of dependencies to reduce cold start times

**TypeScript**:
- Strict mode enabled
- Shared types between client/server via path aliases

### Authentication (Planned)

**Replit Auth**:
- OAuth provider integration
- No additional API keys required when deployed on Replit
- Falls back to mock auth in development

### Package Management

**Key Dependencies**:
- `@tanstack/react-query` - Server state management
- `react-hook-form` + `zod` - Type-safe form validation
- `drizzle-orm` + `drizzle-zod` - Database ORM with Zod integration
- `wouter` - Lightweight routing
- `express-session` - Session management

**Build Tools**:
- `tsx` - TypeScript execution for development
- `esbuild` - Production server bundling
- `drizzle-kit` - Database migration tool